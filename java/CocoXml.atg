/*-------------------------------------------------------------------------
CocoXml.ATG -- Attributed Grammar
Compiler Generator CocoXml/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by W. Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of CocoXml/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by CocoXml/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   javac Coco.Coco CocoXml.ATG -package CocoXml
-------------------------------------------------------------------------*/

COMPILER CocoXml

	static final int id = 0;
	static final int str = 1;
	
	public Trace trace;         // other Coco objects referenced by this ATG
	public Tab tab;
	public XmlScannerData xsdata;
	public ParserGen pgen;

	boolean genScanner;

/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit     = "0123456789".
  cr        = '\r'.
  lf        = '\n'.
  tab       = '\t'.
  stringCh  = ANY - '"' - '\\' - cr - lf.
  charCh    = ANY - '\'' - '\\' - cr - lf.
  printable = '\u0020' .. '\u007e'.
  hex       = "0123456789abcdef".

TOKENS
  ident     = ( letter | '_' ) { letter | digit | '_' }.
  number    = digit { digit }.
  string    = '"' { stringCh | '\\' printable } '"'.
  badString = '"' { stringCh | '\\' printable } (cr | lf).
  char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
  ddtSym    = '$' { digit | letter }.  (. tab.SetDDT(la.val); .)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

CocoXml                         (. Symbol sym; Graph g; String gramName; XmlLangDefinition xldef; .)
=
  [ Imports<out pgen.usingPos> ]

  "COMPILER"                    (. genScanner = true; .)
  ident                         (. gramName = t.val;
                                   int beg = la.pos;
                                 .)
  { ANY }                       (. tab.semDeclPos = new Position(beg, la.pos-beg, 0); .)

  XmlLangDefinition<out xldef>  (. xsdata.Add("", xldef); .)

  { XmlNamespaceDeclaration }

  SYNC
  "PRODUCTIONS"                 (. tab.DeleteNodes(); .)
  { ident                       (. sym = tab.FindSym(t.val);
                                   boolean undef = sym == null;
                                   if (undef) sym = tab.NewSym(Node.nt, t.val, t.line);
                                   else {
                                     if (sym.typ == Node.nt) {
                                       if (sym.graph != null) SemErr("name declared twice");
                                     } else SemErr("this symbol kind not allowed on left side of production");
                                     sym.line = t.line;
                                   }
                                   boolean noAttrs = sym.attrPos == null;
                                   sym.attrPos = null;
                                   boolean noRet = sym.retVar==null;
                                   sym.retVar = null;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef)
                                     if (noAttrs != (sym.attrPos == null)
                                       || noRet != (sym.retVar == null))
                                       SemErr("attribute mismatch between declaration and use of this symbol");
                                 .)
    [ SemText<out sym.semPos> ]
    WEAK '='
    Expression<out g>           (. sym.graph = g.l;
                                   tab.Finish(g);
                                 .)
    WEAK '.'
  }
  "END" ident                   (. if (gramName.compareTo(t.val) != 0)
                                     SemErr("name does not match grammar name");
                                   tab.gramSy = tab.FindSym(gramName);
                                   if (tab.gramSy == null)
                                     SemErr("missing production for grammar name");
                                   else {
                                     sym = tab.gramSy;
                                     if (sym.attrPos != null)
                                       SemErr("grammar symbol must not have attributes");
                                   }
                                   tab.noSym = tab.NewSym(Node.t, "???", 0); // noSym gets highest number
                                   tab.SetupAnys();
                                   tab.RenumberPragmas();
                                   if (tab.ddt[2]) tab.PrintNodes();
                                   if (errors.count == 0) {
                                     System.out.println("checking");
                                     tab.CompSymbolSets();
                                     if (tab.ddt[7]) tab.XRef();
                                     if (tab.GrammarOk()) {
                                       System.out.print("parser");
                                       pgen.WriteXmlParser();
                                       if (genScanner) {
                                         System.out.print(" + scanner");
                                         xsdata.WriteXmlScanner();
					 /* if (tab.ddt[0]) xsdata.PrintStates(); */
                                       }
                                       System.out.println(" generated");
                                       if (tab.ddt[8]) pgen.WriteStatistics();
                                     }
                                   }
                                   if (tab.ddt[6]) tab.PrintSymbolTable();
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

XmlNamespaceDeclaration         (. String namespace_name; XmlLangDefinition xldef; .)
=
  "NAMESPACE"
  string                        (. namespace_name = t.val; .)
  "{"
  XmlLangDefinition<out xldef>  (. xsdata.Add(namespace_name, xldef); .)
  "}"
.

/*------------------------------------------------------------------------------------*/

XmlLangDefinition<out XmlLangDefinition xldef>
= (. xldef = new XmlLangDefinition(tab, errors); .)
  [ "OPTIONS" { OptionDecl<xldef> } ]
  [ "TAGS" { XmlTagDecl<xldef> } ]
  [ "ATTRS" { XmlAttrDecl<xldef> } ]
.

/*------------------------------------------------------------------------------------*/
/* For the possible values, see XSData.java. */
OptionDecl<XmlLangDefinition xldef>
=
  ident (. xldef.AddOption(t.val, t.line); .)
.

/*------------------------------------------------------------------------------------*/

XmlTagDecl<XmlLangDefinition xldef>  (. String tokenName; .)
=
  ident  (. tokenName = t.val; .)
  "="
  string (. xldef.AddTag(t.val, tokenName, t.line); .)
.

/*------------------------------------------------------------------------------------*/

XmlAttrDecl<XmlLangDefinition xldef>  (. String tokenName; .)
=
  ident  (. tokenName = t.val; .)
  "="
  string (. xldef.AddAttr(t.val, tokenName, t.line); .)
.

/*------------------------------------------------------------------------------------*/

AttrDecl<Symbol sym>            (. int beg, col; .)
= 
  '<'                           // attributes denoted by < ... >
  ( ('^' | "out")               (. beg = la.pos; .)
    TypeName                    (. sym.retType = scanner.buffer.GetString(beg, la.pos); .)
    ident                       (. sym.retVar = t.val; .)
    ( '>'
    | ','                       (. beg = la.pos; col = la.col; .)
      { ANY
      | badString               (. SemErr("bad string in attributes"); .)
		  } '>'                     (. if (t.pos > beg)
                                     sym.attrPos = new Position(beg, t.pos - beg, col); .)
    )
  |                             (. beg = la.pos; col = la.col; .)
	  {  ANY
	  | badString                 (. SemErr("bad string in attributes"); .)
	  } '>'                       (. if (t.pos > beg)
	                                   sym.attrPos = new Position(beg, t.pos - beg, col); .)
  )
|
  "<."                          // attributes denoted by <. ... .>
  ( ('^' | "out")               (. beg = la.pos; .)
    TypeName                    (. sym.retType = scanner.buffer.GetString(beg, la.pos); .)
    ident                       (. sym.retVar = t.val; .)
    ( ".>"
    | ','                       (. beg = la.pos; col = la.col; .)
      { ANY
      | badString               (. SemErr("bad string in attributes"); .)
		  } ".>"                    (. if (t.pos > beg)
                                     sym.attrPos = new Position(beg, t.pos - beg, col); .)
    )
  |                             (. beg = la.pos; col = la.col; .)
	  {  ANY
	  | badString                 (. SemErr("bad string in attributes"); .)
	  } ".>"                      (. if (t.pos > beg)
	                                   sym.attrPos = new Position(beg, t.pos - beg, col); .)
  ).

/*------------------------------------------------------------------------------------*/
// type names may contain angle brackets for generics
TypeName
= ident {'.' ident | '[' ']' | '<' TypeName {',' TypeName} '>'}.

/*------------------------------------------------------------------------------------*/

Expression<out Graph g>         (. Graph g2; .)
=
  Term<out g>                   (. boolean first = true; .)
  { WEAK '|'
    Term<out g2>                (. if (first) { tab.MakeFirstAlt(g); first = false; }
                                   tab.MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<out Graph g>               (. Graph g2; Node rslv = null; g = null; .)
=
( [                             (. rslv = tab.NewNode(Node.rslv, null, la.line); .)
    Resolver<out rslv.pos>      (. g = new Graph(rslv);                       .)
  ]
  Factor<out g2>                (. if (rslv != null) tab.MakeSequence(g, g2);
                                   else g = g2;
                                 .)
  { Factor<out g2>              (. tab.MakeSequence(g, g2); .)
  }
|                               (. g = new Graph(tab.NewNode(Node.eps, null, 0)); .)
)                               (. if (g == null) // invalid start of Term
                                     g = new Graph(tab.NewNode(Node.eps, null, 0));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Factor<out Graph g>             (. SymInfo s; Position pos; boolean weak = false;
                                   g = null; .)
=
( [ "WEAK"                      (. weak = true; .)
  ]
  Sym<out s>                    (. Symbol sym = tab.FindSym(s.name);
                                   if (sym == null && s.kind == str)
                                     sym = tab.literals.get(s.name);
                                   boolean undef = sym == null;
                                   if (undef) {
                                     if (s.kind == id)
                                       sym = tab.NewSym(Node.nt, s.name, 0);  // forward nt
                                     else if (genScanner) {
                                       sym = tab.NewSym(Node.t, s.name, t.line);
                                     } else {  // undefined string in production
                                       SemErr("undefined string in production");
                                       sym = tab.eofSy;  // dummy
                                     }
                                   }
                                   int typ = sym.typ;
                                   if (typ != Node.t && typ != Node.nt)
                                     SemErr("this symbol kind is not allowed in a production");
                                   if (weak)
                                     if (typ == Node.t) typ = Node.wt;
                                     else SemErr("only terminals may be weak");
                                   Node p = tab.NewNode(typ, sym, t.line);
                                   g = new Graph(p);
                                 .)
  [ Attribs<p>                  (. if (s.kind != id) SemErr("a literal must not have attributes"); .)
  ]                             (. if (undef) {
                                     sym.attrPos = p.pos;  // dummy
                                     sym.retVar = p.retVar;  // AH - dummy
                                   } else if ((p.pos == null) != (sym.attrPos == null)
                                          || (p.retVar == null) != (sym.retVar == null))
                                     SemErr("attribute mismatch between declaration and use of this symbol");
                                 .)
| '(' Expression<out g> ')'
| '[' Expression<out g> ']'     (. tab.MakeOption(g); .)
| '{' Expression<out g> '}'     (. tab.MakeIteration(g); .)
| SemText<out pos>              (. Node p = tab.NewNode(Node.sem, null, 0);
                                   p.pos = pos;
                                   g = new Graph(p);
                                 .)
| "ANY"                         (. Node p = tab.NewNode(Node.any, null, 0);  // p.set is set in tab.SetupAnys
                                   g = new Graph(p);
                                 .)
| "SYNC"                        (. Node p = tab.NewNode(Node.sync, null, 0);
                                   g = new Graph(p);
                                 .)
)                               (. if (g == null) // invalid start of Factor
                                     g = new Graph(tab.NewNode(Node.eps, null, 0));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Resolver<out Position pos>
=
  "IF" "("                      (. int beg = la.pos; int col = la.col; .)
  Condition                     (. pos = new Position(beg, t.pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

Sym<out SymInfo s>
=                               (. s = new SymInfo(); s.name = "???"; s.kind = id; .)
( ident                         (. s.kind = id; s.name = t.val; .)
| (string                       (. s.name = t.val; .)
  | char                        (. s.name = "\"" + t.val.substring(1, t.val.length()-1) + "\""; .)
  )                             (. s.kind = str;
                                   if (s.name.indexOf(' ') >= 0)
                                     SemErr("literal tokens must not contain blanks"); .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<Node n>                 (. int beg, col; .)
=
  '<'                           // attributes denoted by < ... >
  ( ('^' | "out")               (. beg = la.pos; .)
    { ANY
    | Bracketed
    | badString                 (. SemErr("bad string in attributes"); .)
    }                           (. n.retVar = scanner.buffer.GetString(beg, la.pos); .)
    ( '>'
    | ','                       (. beg = la.pos; col = la.col; .)
      {  ANY
       | badString              (. SemErr("bad string in attributes"); .)
      } '>'                     (. if (t.pos > beg) n.pos = new Position(beg, t.pos - beg, col); .)
    )
  |                             (. beg = la.pos; col = la.col; .)
    {  ANY
     | badString                (. SemErr("bad string in attributes"); .)
    } '>'                       (. if (t.pos > beg) n.pos = new Position(beg, t.pos - beg, col); .)
  )
|
	"<."                          // attributes denoted by <. ... .>
  ( ('^' | "out")               (. beg = la.pos; .)
    { ANY
    | Bracketed
    | badString                 (. SemErr("bad string in attributes"); .)
    }                           (. n.retVar = scanner.buffer.GetString(beg, la.pos); .)
    ( ".>"
    | ','                       (. beg = la.pos; col = la.col; .)
      {  ANY
       | badString              (. SemErr("bad string in attributes"); .)
      } ".>"                    (. if (t.pos > beg) n.pos = new Position(beg, t.pos - beg, col); .)
    )
  |                             (. beg = la.pos; col = la.col; .)
    {  ANY
     | badString                (. SemErr("bad string in attributes"); .)
    } ".>"                      (. if (t.pos > beg) n.pos = new Position(beg, t.pos - beg, col); .)
  )
.

/*------------------------------------------------------------------------------------*/
// skip commas in brackets such as in <out a[i, j], b> or <out a[foo(x, y)], z>
Bracketed
= '(' {Bracketed | ANY} ')' | '[' {Bracketed | ANY} ']'.

/*------------------------------------------------------------------------------------*/

SemText<out Position pos>
=
  "(."                          (. int beg = la.pos; int col = la.col; .)
  { ANY
  | badString                   (. SemErr("bad string in semantic action"); .)
  | "(."                        (. SemErr("missing end of previous semantic action"); .)
  }
  ".)"                          (. pos = new Position(beg, t.pos - beg, col); .)
.

/*------------------------------------------------------------------------------------*/

Imports<out Position pos>
=
  "import"                      (. int beg = t.pos; .)
  { ANY } ';'                   (. int end = t.pos; .)
  { "import" { ANY } ';'        (. end = t.pos; .)
  }                             (. pos = new Position(beg, end - beg + 1, 0); .)
.

END CocoXml.
